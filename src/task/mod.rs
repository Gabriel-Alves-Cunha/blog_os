use alloc::boxed::Box;
use core::{future::Future, pin::Pin}; // Heap allocated

pub struct Task {
  id: TaskId,
  future: Pin<Box<dyn Future<Output = ()>>>, // We require that the future associated with a task returns (). This means that tasks don't return any result, they are just executed for its side effects.
  // The dyn keyword indicates that we store a trait object in the Box. This means that the methods on the future are dynamically dispatched, which makes it possible to store different types of futures in the Task type. This is important because each async fn has its own type and we want to be able to create multiple different tasks.
  // The Pin<Box> type ensures that a value cannot be moved in memory by placing it on the heap and preventing the creation of &mut references to it. This is important because futures generated by async/await might be self-referential, i.e. contain pointers to itself that would be invalidated when the future is moved.
}

use core::task::{Context, Poll};

impl Task {
  pub fn new(future: impl Future<Output = ()> + 'static) -> Task {
    Task {
      id: TaskId::new(),
      future: Box::pin(future),
    } // The 'static lifetime is required here because the returned Task can live for an arbitrary time, so the future needs to be valid for that time too.
  }

  fn poll(&mut self, context: &mut Context) -> Poll<()> {
    self.future.as_mut().poll(context)
  }
}

pub mod simple_executor; // Since the Task::poll method should be only called by the executor that we create in a moment, we keep the function private to the task module. Since executors can be quite complex, we deliberately start with creating a very basic executor before we implement a more featureful executor later. For this, we first create a new task::simple_executor submodule:

pub mod keyboard;

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
struct TaskId(u64);

use core::sync::atomic::{AtomicU64, Ordering};

impl TaskId {
  fn new() -> Self {
    static NEXT_ID: AtomicU64 = AtomicU64::new(0);

    TaskId(NEXT_ID.fetch_add(1, Ordering::Relaxed))
  }
}

pub mod executor;
